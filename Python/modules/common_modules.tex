\subsection{Math}

\begin{minted}[breaklines=true]{python}
import math
\end{minted}

\begin{tabular}{@{}ll@{}}
    \verb!!    & absolute value \\
    \verb!!    & round value \\
    \verb!()!    & sine \\
    \verb!cos()!    & cosine \\
    \verb!tan()!    & tangent \\
    \verb!sqrt()!    & square root \\
    \verb!log()!    & logarithm \\
    \verb!ceil()!    & ceil \\
    \verb!floor()!    & floor \\
\end{tabular}



\subsection{Argumens Parser}

\begin{minted}[breaklines=true]{python}
import argparse

# create object
arg = argparse.ArgumentParser()

# add argument
arg.add_argument('-strink_arg_name', 'full_arg_name', required=True, help='description')

args = vars(arg.parse_args())
\end{minted}



\subsection{Filesystem}

\begin{minted}[breaklines=true]{python}
from pathlib import Path

# creating path
address = Path('home', '...', 'file')
actual_path = Path.cwd()
home_path = Path.home()

# absolute path
address.is_absolute()

# get path parts
address.parent      # previous folder
address.name        # final position
address.stem        # home
address.drive
\end{minted}



\subsection{File Management}

\subsubsection{csv}

\begin{minted}[breaklines=true]{python}
import csv

# write
f = open('file.csv', 'w', newline = '')
f_csv = csv.writer(f, delimiter='\t', lineterminator='\n\n')
f_csv.writerow(['elem_0', ..., 'elem_n'])

# write as dictionary
f = open('file.csv', 'w', newline = '')
f_csv = csv.DictWriter(f, ['key_0', ..., 'key_n'])
f_csv.writeheader()
f_csv.writerow({'key_0': value_0, ..., 'key_n': value_n})

# read
f = open('file.csv', 'r')
f_csv = csv.reader(f)
for row in f_csv:
    print('Row #' + str(f_csv.line_num) + ' ' + str(row))

# read dictionary
f = open('file.csv')

f_csv = csv.DictReader(f, ['key_0', ..., 'key_n'])
for row in f_csv:
    print(row['key_0'], ..., row['key_n'])

# close
f.close()
\end{minted}


\subsubsection{json}

\begin{minted}[breaklines=true]{python}
import json

# write
json_write = {'key_0': value_0, ..., 'key_n': value_n}
stringOfJsonData = json.dumps(json_write)

# read
json_read = '{'key_0': value_0, ..., 'key_n': value_n}'
jsonDataAsPythonValue = json.loads(json_read)
print(jsonDataAsPythonValue)
\end{minted}



\subsection{Regular Expression}

\begin{minted}[breaklines=true]{python}
# object
regex_obj = re.compile(r'string_to_match')

# find the first result
match = regex_obj.search(Text)
regex_obj.search.group()
regex_obj.search.groups()

# find all results and replace
match = regex_obj.findall(Text)

# censoring data
Censored_Text = regex_obj.sub(r'CENSORED', Text)
\end{minted}


\begin{tabular}{@{}ll@{}}
    string\_to\_match: \\
    \verb!string!    & specific string \\
    \verb!(\d\D{1})(\w{2}\W)!    &  \\
    \verb!(...)!    & grouping \\
    \verb![]!    & create a character class \\
    \verb!+!    & match one or more characters \\
    \verb!*!    & match zero or more characters \\
    \verb!?!    & match zero or one character \\
    \verb!.!    & match any character except for newline \\
    \verb!^string!    & start with \\
    \verb!string&!    & end with \\
\end{tabular}








\subsection{Green thread process}
Multi-threading (aka "Green thread process") is used in IO applications.

\begin{minted}[breaklines=true]{python}
import threading

def fun_name(...):
    ...

# thread 1
t1 = threading.Thread(target=fun_name)
t1.deamon = True
t1.start()

# thread 2
t2 = threading.Thread(target=fun_name)
t2.deamon = True
t2.start()
\end{minted}
        

        


\subsection{Multiprocessing}
This method is the proper multi-threading.

\begin{minted}[breaklines=true]{python}
import numpy as np
from numba import njit
from concurrent.futures import ThreadPoolExecutor

# function definition
def fun_name(...):
    ...

# multi-process function
multi_fun = njit(fun_name, nogil=True)


# process 1
with ThreadPoolExecutor(8) as ex:
    ex.map(multi_fun, range(100))

# process 2
with ThreadPoolExecutor(8) as ex:
    ex.map(multi_fun, range(10))
\end{minted}



